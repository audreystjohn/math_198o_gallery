<!DOCTYPE html>
<head>
<meta charset="utf-8">
<title>Interactive Gallery</title>
<style>

#help{
/*  position:absolute;
  top:0;
  left:0;
  right:0;*/
  text-align: center;
}

path.polygon {
  stroke: #000;
  fill: #eee;
  line-width: 5px;
}
path.polygon.bad {
  fill: transparent;
}
path.triangulation {
  stroke: #797;
  fill: transparent;
  line-width: 4px;
  pointer-events:none;
}
path.guard_vis {
  stroke: transparent;
  fill: rgba(255,0,0,0.3);
  pointer-events:none;
}

circle.polygon_v {
  fill: #00F;
}
circle.guard {
  fill: #000;
}

</style>
</head>
<body>
<div id="help">
Click inside the polygon to spawn new guards.</br>
Click any existing guard or vertex to remove it.</br>
Drag any point to move it, and shift-drag on a polygon vertex to add a new vertex.</br>
Finally, click <a href="#" id="triangulater">here</a> to automatically place guards.
</div>
<script src="//d3js.org/d3.v3.min.js"></script>
<script>

var width = 960,
    height = 500;

var polygon = [[300,300], [600,300], [450,450]];
var polygon_is_good = true;

var guards = [[450,375], [500,375], [550,325]];
var guard_vis = [ [[300,300], [400,300], [450,450]], [[350,300], [600,300], [450,450]], [[325,300], [400,300], [500,450]] ];

var triangulation = [[[300,300], [450,300], [450,450]], [[450,300], [600,300], [450,450]]];

//////////////////////////

function dragmove(d,i) {
  console.log("Drag");
  d[0] += d3.event.dx;
  d[1] += d3.event.dy;

  if(d[0]<0) d[0]=0;
  if(d[0]>width) d[0]=width;
  if(d[1]<0) d[1]=0;
  if(d[1]>width) d[1]=height;

  d3.select(this).attr("transform", function(d,i){
    return "translate(" + d + ")"
  });
  triangulation = [];
  update();
}

function drag_removeguards(){
  for (var i = 0; i < guards.length; i++) {
    var g = guards[i];
    if(!check_inside(g,polygon)){
      console.log("Guard dragged out!");
      guards.splice(i,1);
      i--;
    }
  };
  update();
}

function drag_spawnpoly(d,i) {
  console.log("Start");
  if(d3.event.sourceEvent.shiftKey){
    console.log("Drag spawn!");
    var copy = d.slice();
    polygon.splice(i,0,copy);
  }
  update();
}

var dragguard = d3.behavior.drag()
        .on("drag", dragmove)
        .on("dragend",drag_removeguards);

var dragpoly = d3.behavior.drag()
        .on("drag", dragmove)
        .on("dragstart",drag_spawnpoly)
        .on("dragend",drag_removeguards);

function click_to_remove(x, sourcearray, min){
  min = min | 0;
  x.on("click.to_rem", function(d,i){
    if (d3.event.defaultPrevented) return;
    if (sourcearray.length <= min) return;
    sourcearray.splice(i,1);
    update();
  });
}

function click_spawn_guard(x){
  x.on("click.spawn", function(d,i){
    if (d3.event.defaultPrevented) return;
    pos = d3.mouse(svg[0][0]);
    guards.push(pos);
    update();
  });
}

var svg = d3.select("body").append("svg")
    .attr("width", width)
    .attr("height", height)

var polygon_path = svg.append("g").selectAll("path.polygon");
var triangulation_path = svg.append("g").selectAll("path.triangulation");
var guard_vis_path = svg.append("g").selectAll("path.guard_vis");
var polygon_verts = svg.append("g").selectAll("circle.polygon_v");
var guard_verts = svg.append("g").selectAll("circle.guard");

update();

function determinant(a,b,c,d){
  return a*d - b*c;
}

function intersect_edges(a1,a2,b1,b2){
  // s a1x + (1-s) a2x = t b1x + (1-t) a2x
  var a = a1[0];
  var b = a2[0]-a1[0];
  var c = b1[0];
  var d = b2[0]-b1[0];
  var e = a1[1];
  var f = a2[1]-a1[1];
  var g = b1[1];
  var h = b2[1]-b1[1];

  var det = determinant(b,-d,f,-h);
  var a_time = determinant(c-a,-d,g-e,-h)/det;
  var b_time = determinant(b,c-a,f,g-e)/det;

  return {a:a_time,b:b_time};
}

function vector_angle(x1,y1,x2,y2){
  var dot = x1*x2 + y1*y2;
  var cross_z = x1*y2 - y1*x2;
  var angle = Math.atan2(cross_z,dot);
  return angle;
}

function check_simple(poly){
  // STUB: Should return true if polygon is simple
  // (doesn't cross itself)
  for (var i = 0; i < poly.length; i++) {
    var v1 = poly[i];
    var v2 = poly[(i+1)%poly.length];
    var j = 0;
    if(i==poly.length-1) j=1;
    for (; j < i-1; j++) {
      var v3 = poly[j];
      var v4 = poly[(j+1)%poly.length];
      var ires = intersect_edges(v1,v2,v3,v4);
      if(!(ires.a < 0 || ires.a > 1 || ires.b < 0 || ires.b > 1)){
        return false;
      }
    }
  };
  return true;
}

function check_clockwise(poly){
  var cum_ang = 0;
  for (var i = 0; i < poly.length; i++) {
    var v1 = poly[i];
    var v2 = poly[(i+1)%poly.length];
    var v3 = poly[(i+2)%poly.length];
    cum_ang += vector_angle(v2[0]-v1[0],v2[1]-v1[1],v3[0]-v2[0],v3[1]-v2[1]);
  };
  console.log(cum_ang);
  return cum_ang > 0;
}

function check_inside(point,poly){
  // Return true if the [x,y] point is in the polygon, which
  // is guaranteed to be simple.
  var EPSILON = 0.000001;
  var end = [point[0], 2*height];
  var num_intersects = 0;
  for (var i = 0; i < poly.length; i++) {
    var v1 = poly[i];
    var v2 = poly[(i+1)%poly.length];
    // bump them if they are in line with the guard
    if(v1[0]==point[0]) v1=[v1[0]+EPSILON, v1[1]];
    if(v2[0]==point[0]) v2=[v2[0]+EPSILON, v2[1]];

    var ires = intersect_edges(point,end,v1,v2);
    if(ires.a>=0 && ires.b >= 0 && ires.b < 1){
      num_intersects++;
    }
  };
  console.log(num_intersects);
  return (num_intersects%2) == 1;
}

function generate_guard_vis(guard,poly){
  // STUB: Given a [x,y] guard position (guaranteed inside the polygon),
  // should return a polygon of the form
  // [[x1,y1],[x2,y2],...]
  // that represents the guard's visibility as a simple,
  // clockwise-oriented polygon
  var x = guard[0];
  var y = guard[1];
  return [[x-10,y-10],[x+10,y-10],[x,y+10]];
}

function generate_triangulation_and_guard_pos(poly){
  // STUB: Triangulate the polygon, place guards, and return
  // [triangulation, guard posns]
  // where triangulation is an array of triangles
  // [[x1,y1],[x2,y2],[x3,y3]]
  // and guard posns is an array of points [x,y]
  g = [[450,375], [500,375], [550,375]];
  t = [[[300,300], [450,300], [450,450]], [[450,300], [600,300], [450,450]]];
  return [t,g];
}

document.getElementById("triangulater").addEventListener("click", function(){
  t_g = generate_triangulation_and_guard_pos(polygon);
  triangulation = t_g[0];
  guards = t_g[1];
  update();
});

function update(){
  polygon_is_good = check_simple(polygon) && check_clockwise(polygon);
  if(polygon_is_good){
    guard_vis = [];
    for (var i = 0; i < guards.length; i++) {
      var guard = guards[i];
      if(check_inside(guard,polygon)){
        guard_vis.push(generate_guard_vis(guard,polygon));
      }
    }
  }else{
    guard_vis = [];
  }

  redraw();
}

function redraw(){
  polygon_path = polygon_path.data([polygon]);
  polygon_path.exit().remove();
  polygon_path.enter().append("path").attr("class","polygon");
  polygon_path.attr("d", poly_d_fn)
      .call(click_spawn_guard);

  if(polygon_is_good){
    polygon_path.attr("class", "polygon");
  }else{
    polygon_path.attr("class", "polygon bad");
  }

  triangulation_path = triangulation_path.data(triangulation);
  triangulation_path.exit().remove();
  triangulation_path.enter().append("path").attr("class","triangulation");
  triangulation_path.attr("d", poly_d_fn);

  guard_vis_path = guard_vis_path.data(guard_vis);
  guard_vis_path.exit().remove();
  guard_vis_path.enter().append("path").attr("class","guard_vis");
  guard_vis_path.attr("d", poly_d_fn);
  
  polygon_verts = polygon_verts.data(polygon);
  polygon_verts.exit().remove();
  polygon_verts.enter().append("circle");
  polygon_verts.attr("class","polygon_v")
      .attr("transform", function(d) { return "translate(" + d + ")"; })
      .attr("r", 5)
      .call(dragpoly).call(click_to_remove,polygon,3);

  guard_verts = guard_verts.data(guards);
  guard_verts.exit().remove();
  guard_verts.enter().append("circle");
  guard_verts.attr("class","guard")
      .attr("transform", function(d) { return "translate(" + d + ")"; })
      .attr("r", 5)
      .call(dragguard).call(click_to_remove,guards);
}

function poly_d_fn(d) {
  return "M" + d.join("L") + "Z";
}

</script>
</body>
</html>